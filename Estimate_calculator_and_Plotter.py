# -*- coding: utf-8 -*-
"""BTP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wV-q3jh_dRA2ntw1o5WIuOI0s9RfMdnH
"""

import numpy as np
import matplotlib.pyplot as plt

def a_0(a_1):
  return 0

def a_1(a_1):
  return a_1

def a_2(a_1):
  return (1+a_1**2)/4

def a_3(a_1):
  return (2/3)*(a_1)*a_2(a_1)

def a_4(a1):
    return (36*a1*a_3(a1) + 16*(a_2(a1))**2) / 48

def a_5(a1):
    return (192*a1*a_4(a1) + 168*a_2(a1)*a_3(a1)) / 240

def a_6(a1):
    return (1200*a1*a_5(a1) + 1056*a_2(a1)*a_4(a1) + 504*(a_3(a1))**2) / 1440

def a_7(a1):
    return (8640*a1*a_6(a1) + 7680*a_2(a1)*a_5(a1) + 7200*a_3(a1)*a_4(a1)) / 10080

def a_8(a1):
    return (
        70560*a1*a_7(a1)
        + 63360*a_2(a1)*a_6(a1)
        + 59040*a_3(a1)*a_5(a1)
        + 28800*(a_4(a1))**2
    ) / 80640

def a_9(a1):
    return (
        645120*a1*a_8(a1)
        + 584640*a_2(a1)*a_7(a1)
        + 544320*a_3(a1)*a_6(a1)
        + 524160*a_4(a1)*a_5(a1)
        + 2620800*(a_5(a1))**2
    ) / 725760

def a_10(a1):
    return (
        6531840*a1*a_9(a1)
        + 5967360*a_2(a1)*a_8(a1)
        + 5564160*a_3(a1)*a_7(a1)
        + 5322240*a_4(a1)*a_6(a1)
        + 2620800*(a_5(a1))**2
    ) / 7257600

def a_11(a1):
    return (
        72576000*a1*a_10(a1)
        + 66769920*a_2(a1)*a_9(a1)
        + 62415360*a_3(a1)*a_8(a1)
        + 59512320*a_4(a1)*a_7(a1)
        + 58060800*a_5(a1)*a_6(a1)
    ) / 79833600

def a_12(a1):
    return (
        878169600*a1*a_11(a1)
        + 812851200*a_10(a1)*a_2(a1)
        + 762048000*a_3(a1)*a_9(a1)
        + 725760000*a_4(a1)*a_8(a1)
        + 703987200*a_5(a1)*a_7(a1)
        + 348364800*(a_6(a1))**2
    ) / 958003200

def a_13(a1):
    return (
        11496038400*a1*a_12(a1)
        + 10059033600*a_10(a1)*a_3(a1)
        + 10697702400*a_11(a1)*a_2(a1)
        + 9580032000*a_4(a1)*a_9(a1)
        + 9260697600*a_5(a1)*a_8(a1)
        + 9101030400*a_6(a1)*a_7(a1)
    ) / 12454041600

def a_14(a1):
    return (
        161902540800*a_1(a1)*a_13(a1)
        + 136036454400*a_10(a1)*a_4(a1)
        + 142742476800*a_11(a1)*a_3(a1)
        + 151364505600*a_12(a1)*a_2(a1)
        + 131246438400*a_5(a1)*a_9(a1)
        + 128372428800*a_6(a1)*a_8(a1)
        + 63707212800*(a_7(a1))**2
    ) / 174356582400

def a_15(a1):
    return (
        2440992153600*a_14(a1)
        + 1992646566000*a_10(a1)*a_5(a1)
        + 2067370905600*a_11(a1)*a_4(a1)
        + 2167003238400*a_12(a1)*a_3(a1)
        + 2291543654400*a_13(a1)*a_2(a1)
        + 1942830489600*a_6(a1)*a_9(a1)
        + 1917922406400*a_7(a1)*a_8(a1)
    ) / 2615348736000

a_i = [a_0,a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9,a_10,a_11,a_12,a_13,a_14,a_15]

t = np.linspace(0, 2*np.pi, 1000)
c1 = 0.5729170376
t_range = 0.7677*np.pi
x_1 = c1*(t - np.sin(t))-1
y_1 = 1 - c1*(1 - np.cos(t))
mask = (x_1<=0) & (x_1>=-1)
x_1 = x_1[mask]
y_1 = y_1[mask]

x = np.array([0,0,-0.64575,-.55313,0,0,0,-0.45043,0,0,0,-0.42447,0,0,0,-0.412708])
y_2 = -0.37*x_1 + a_2(x[2])*x_1**2
#y_3 = x[3]*x_1 + a_2(x[3])*x_1**2 + a_3(x[3])*x_1**3
#diff3 = y_3 - y_1
diff2 = y_2 - y_1

# crossing_point = np.where(np.diff(np.sign(y_2-0.6)))[0]
y = []
for i in range(len(x)):
  if x[i]==0:
    y.append(np.array([]))
    continue
  y_temp = np.zeros_like(x_1)
  for j in range(1,i+1):
    y_temp += a_i[j](x[i])*x_1**j
  y.append(y_temp)

plt.figure(figsize = (18, 10))
plt.plot(x_1,y_1,linestyle="--", label= "Ideal")
#plt.plot(x_1,y_1-y_2,label = "Approximation_2")
for i in range(len(x)):
  if y[i].size==0:
    continue
  plt.plot(x_1,y[i], label = f"Approximation {i}")
  plt.plot(x_1,y[i]-y_1, label= f"Difference {i}")
plt.xlabel("x")
plt.ylabel("y")
plt.legend()
plt.grid(True, which='both', linestyle='--', alpha=0.5)
plt.minorticks_on()
plt.show()

"""

---


---




---

"""

# Power series coefficient definitions (each takes a_1 as parameter)
def a_0(a_1):
    return 0
def a_1_fn(a_1):
    return a_1
def a_2(a_1):
    return (1 + a_1**2) / 4
def a_3(a_1):
    return (2/3) * a_1 * a_2(a_1)

a_i = [a_0, a_1_fn, a_2, a_3]

# Parametric domain
t = np.linspace(0, 2 * np.pi, 500)
c1 = 0.5729170376

# Brachistochrone/X-domain
x_1_full = c1 * (t - np.sin(t)) - 1
y_1_full = 1 - c1 * (1 - np.cos(t))

# Mask for x in [-1, 0]
mask = (x_1_full <= 0) & (x_1_full >= -1)
x_1 = x_1_full[mask]
y_1 = y_1_full[mask]

# Array of a_1 values (set as you need; here, as example)
x = np.array([0, 0, -0.64575, -0.55313])

# Build the power series for each a_1 value in x
y = []
for i in range(len(x)):
    if x[i] == 0:
        y.append(np.array([]))  # store empty array for plotting skip
        continue
    y_temp = np.zeros_like(x_1)
    for j in range(1, i + 1):
        y_temp += a_i[j](x[i]) * x_1**j
    y.append(y_temp)

# Plot the power-series curves vs the original y_1 curve
plt.figure(figsize=(10, 6))
plt.plot(x_1, y_1, 'k--', label="Ideal $y_1$")

for i in range(len(y)):
    if y[i].size == 0:
        continue
    plt.plot(x_1, y[i], label=f"Power series $a_1$={x[i]} (order {i})")
    plt.plot(x_1, y[i] - y_1, linestyle=':', label=f"Difference $a_1$={x[i]}")

plt.xlabel("x")
plt.ylabel("y")
plt.title("Power Series Approximations vs Ideal Curve")
plt.legend()
plt.grid(True, which='both', linestyle='--', alpha=0.5)
plt.minorticks_on()
plt.show()